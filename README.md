
```markdown
# Data Structures and Algorithms - LAB 1

This repository contains my implementation of various algorithms and data structures, specifically focusing on solving problems related to recursion, time efficiency, and peak element search.

## Table of Contents

1. [Introduction](#introduction)
2. [Algorithms Implemented](#algorithms-implemented)
3. [Instructions to Run](#instructions-to-run)
4. [Challenges and Observations](#challenges-and-observations)

## Introduction

In this project, I have implemented several algorithms and data structures to solve real-world problems. The main goal is to practice improving time complexity and space efficiency while maintaining accurate outputs. The project includes recursive algorithms, improved iterative solutions, and the search for peak elements in an array.

## Algorithms Implemented

1. **Fibonacci Sequence (Recursive Approach)**  
   A basic recursive solution for calculating Fibonacci numbers. I also implemented an optimized solution that uses an iterative approach for better time efficiency.

2. **Improved Fibonacci Solution**  
   I improved the Fibonacci sequence by using dynamic programming techniques such as memoization to store intermediate results, drastically reducing the time complexity.

3. **Peak Element in an Array**  
   I implemented an algorithm to find a peak element in an array. A peak element is an element that is greater than its neighbors. This algorithm ensures efficiency even for larger arrays.

## Instructions to Run

### Clone the Repository:

```bash
git clone https://github.com/benedictgodhana/DATA_STRUCTURES_AND_ALGORITHMS.git
```

### Navigate to the Project Directory:

```bash
cd DATA_STRUCTURES_AND_ALGORITHMS
```

### Compile the Java Code:

To compile the Java code, use the following command:

```bash
javac LAB1/*.java
```

### Run the Program:

To run the program, use the following command:

```bash
java LAB1.Main
```

## Challenges and Observations

- **Recursive Solutions**: The initial recursive implementations of algorithms like Fibonacci were inefficient due to repeated calculations. 
- **Optimization**: The solution was optimized using memoization and dynamic programming techniques to reduce time complexity and improve performance.
- **Peak Element**: The algorithm for finding a peak element ensures that it checks neighboring elements efficiently without unnecessary calculations.

Feel free to explore the code and modify it for further improvements!

---

**Author**: Benedict Godhana  
**Date**: January 2025  
```
